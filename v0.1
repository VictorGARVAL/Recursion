//Recursión v0.1

/**Método de busqueda ascendente de el menor dígito de un número
  Precondición n >= 0
*/

public static int menorDig(int n){
  if(n < 10){return n;}                                           //Caso base 
  else{int x = menorDig(n/10);                                    //Caso general:variable recalculada para simplificar el problema
       if(x < n%10){retun x;}                                     //Caso general
       else{return n%10;}                                         //Caso general
  }
}

/**Método recursivo para comprobación del juego del multichino
  Precondición x >= 0  &&  0 <= pos < a.length
*/
public static boolean multichinos(int[]a,int x,int pos){                
  if(pos == a.lenght-1){return a[pos] == x;}                      //Caso base de loguitud 1
  else{if(a[pos] > x){return false;}                              //Error por defecto
    else{if(x > 3*(a.lenght-1-pos+1)){return false;}}             //Error por exceso
        else{return multichinos(a,x-a[pos],pos+1);}               //Llamada recursiva
  }
}

/**Método recursivo suma de los numeros menores que n de un array m cualquiera*/
public static int sumaMenores(int[] a,int x,int pos){
  if(pos >= a.length){return 0;}
  else{if(a[pos] <= x){return sumaMenores(a ,x ,pos++) + 1;}
      else{reurn sumaMenores(a ,x ,pos++);}
  }
  
  //Precondición:sea pos un valor comprendido entre 0 y a.length
public static boolean parYcreciente(int [] a,int pos) {
	if(pos == a.length-1) {return a[pos]%2 == 0;}
	else {
		if(a[pos] < a[pos + 1] && a[pos]%2 == 0) {return parYcreciente(a,pos++);}
		else {return false;}
	}
	
	
}
}
